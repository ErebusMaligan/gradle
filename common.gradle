apply plugin: 'java'
import java.nio.file.Paths
import java.io.File

def grp = "assemble"
def util = "util"


//OVERRIDABLE IN SUPER SCRIPT

//relDir -- release directory where everything is assembled to -- defaults to <PROJECT>/build/release

//jarName -- set to the name of the jar file <jarName>.jar -- defaults to <PROJECT NAME>
//mainClass -- set main class qualified name for jar manifest -- defaults to null.  if null, unused and jar is assumed to be not executable

//libProjDir -- project path for the common library project if used this path is used as: <PROJECT ROOT>/../<libProjDir> -- defaults to libs

//deployedProjDir -- Relative to project this path is: <PROJECT ROOT>/../<deployedProjDir> -- defaults to deployed/Tools
//deployedLibDir -- Relative to deployedProjDir

//copyLibs -- set to true if used -- defaults to false
//libDest -- place to copy dependency jars -- defaults to /build/release/libs - always relative to project root

//jarPathPrefix -- 

ext {
	tasks.withType(Zip).all { duplicatesStrategy 'exclude' }
	configurations.implementation.canBeResolved = true

	println( project.findProperty('jarName') ?: projectDir.getName() )

	dependencyJars = project.configurations.implementation.collect { Paths.get( it.getPath() ).toAbsolutePath().toString() }.join(',')
	
	jarPaths = project.findProperty( 'jarPathPrefix' ) ? 
		project.configurations.implementation.collect { project.getProperty( 'jarPathPrefix' ) + it.getName() }.join(' ') :
		project.configurations.implementation.collect { Paths.get( project.libsDirName ).relativize( Paths.get( it.getPath() ).toAbsolutePath() ).toString() }.join(';')
	
	jarNames = project.configurations.implementation.collect { it.getName() }.join(' ')
	
	relFullPath = ( project.findProperty('relDir') ?: ( buildDir.getPath().toString() + "/" + "release" ) )
	jdocPath = buildDir.getPath().toString() + "/docs/javadoc"
	
	libProjPath = projectDir.getPath().toString() + "/../" + ( project.findProperty( 'libProjDir' ) ?: "libs" )
	
	deployedProjPath = projectDir.getPath().toString() + "/../" + ( project.findProperty( 'deployedProjDir' ) ?: "deployed/Tools" )
	deployedProjLibPath = deployedProjPath + "/" + ( project.findProperty( 'deployedLibDir' ) ?: ( project.findProperty( 'libProjDir' ) ?: "libs" ) )
	
	relLibPath = projectDir.getPath().toString() + "/../" + ( project.findProperty( 'libDest' ) ?: ( buildDir.getPath().toString() + "/" + ( project.findProperty('relDir') ?: "release/libs" ) ) )
}


sourceSets {
	main {
		java {
			srcDirs = ['src']
		}
		resources {
			srcDirs = ['src']
			excludes = ["**/*.java"]
		}
	}
}


jar {
	if ( project.findProperty('jarName') ) {
		archiveBaseName = project.findProperty('jarName')
	} 
	if ( project.findProperty('mainClass') ) {
		manifest {
			attributes(
				'Class-Path': project.findProperty('jarPaths') ?: "",
				'Main-Class': project.findProperty('mainClass') ?: ""
			)
	 	}
 	}
}




//STANDARD=================================================================================
task buildRelease( dependsOn: ['assemble', 'clean'] ) {
	group = grp
	tasks.findByName( 'assemble' ).mustRunAfter 'clean'
	doLast {
		delete relFullPath
		copy {
			from ( Paths.get( buildDir.getPath().toString() + "/" + project.relativePath( libsDirName ).toString() ) )
			into ( relFullPath )
		}
		copy {
			from ( projectDir.getPath().toString() ) {
				include 'LICENSE', 'README.md'
			}
			into( relFullPath )
		}
		if ( project.findProperty( 'includeLibs' ) && !dependencyJars.isEmpty() ) {
			copy {
				from ( dependencyJars.split( "," ) )
				into ( relFullPath + "/" + jarPathPrefix )
			}
		}
	}
	if ( project.findProperty( 'copyLibs' ) ) {
		finalizedBy 'copyLibs'
	}
}

task zipRelease( dependsOn: 'buildRelease' ) {
	group = grp
	finalizedBy 'zipRelDir'
}
//=================================================================================




//WITH DOCS=================================================================================
task buildReleaseWithDocs( dependsOn: ['buildRelease', 'javadoc'] ) {
	group = grp
	tasks.findByName( 'javadoc' ).mustRunAfter 'buildRelease'
	finalizedBy 'zipJavaDocs'
}

task zipReleaseWithDocs( dependsOn: 'buildReleaseWithDocs' ) {
	group = grp
	finalizedBy 'zipRelDir'
}
//=================================================================================




//WITH SOURCE=================================================================================
task buildReleaseWithSource( dependsOn: 'buildRelease' ) {
	group = grp
	finalizedBy 'zipSource'
}

task zipReleaseWithSource( dependsOn: 'buildReleaseWithSource' ) {
	group = grp
	finalizedBy 'zipRelDir'
}
//=================================================================================




//WITH SOURCE AND DOCS=================================================================================
task buildReleaseFull( dependsOn: 'buildReleaseWithDocs' ) {
	group = grp
	finalizedBy 'zipSource'
}

task zipReleaseFull( dependsOn: 'buildReleaseFull' ) {
	group = grp
	finalizedBy 'zipRelDir'
}
//=================================================================================




task buildLibJar( dependsOn: 'buildRelease' ) {
	group = util
	doLast {
		copy {
			from ( Paths.get( buildDir.getPath().toString() + "/" + project.relativePath( libsDirName ).toString() ) )
			into ( libProjPath )
		}
	}
}

task buildDeployedLibJar( dependsOn: 'buildRelease' ) {
	group = util
	doLast {
		copy {
			from ( Paths.get( buildDir.getPath().toString() + "/" + project.relativePath( libsDirName ).toString() ) )
			into ( deployedProjLibPath )
		}
	}
}

task zipJavaDocs( type: Zip ) {
	group = util
	archiveBaseName = ( project.findProperty('jarName') ?: projectDir.getName() )
	archiveClassifier = 'doc'
	destinationDirectory = new File( relFullPath )
	from jdocPath
}

task zipSource( type: Zip ) {
	group = util
	archiveBaseName = ( project.findProperty('jarName') ?: projectDir.getName() )
	archiveClassifier = 'src'
	destinationDirectory = new File( relFullPath )
    from sourceSets*.allSource
}


task zipRelDir( type: Zip ) {
	group = util
	archiveBaseName = ( project.findProperty('jarName') ?: projectDir.getName() )
	destinationDirectory = new File( relFullPath )
	from ( relFullPath ) {
		exclude( ( project.findProperty('jarName') ?: projectDir.getName() ) + ".zip" )
	}
	mustRunAfter( zipSource )
	mustRunAfter( zipJavaDocs )
}

task copyLibs() {
	group = util
	doLast {
		if ( !dependencyJars.isEmpty() ) {
			copy {
				from ( dependencyJars.split( "," ) )
				into ( relLibPath )
			}
		}
	}
}